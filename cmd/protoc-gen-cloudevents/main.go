// protoc-gen-cloudevents is a protoc plugin that generates CloudEvents event system code from proto definitions
package main

import (
	"bytes"
	"go/format"
	"log"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"

	cloudevents "github.com/yafeiaa/protoc-gen-cloudevents-go/proto/cloudevents"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	// Collect all messages with event_meta option
	var messages []*messageInfo

	for _, msg := range file.Messages {
		opts, ok := msg.Desc.Options().(*descriptorpb.MessageOptions)
		if !ok {
			continue
		}
		eventMeta := extractEventMeta(opts)
		if eventMeta == nil {
			continue
		}

		messages = append(messages, &messageInfo{
			Name:  msg.GoIdent.GoName,
			Event: eventMeta,
		})
	}

	if len(messages) == 0 {
		return
	}

	// Generate file
	filename := file.GeneratedFilenamePrefix + "_events.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Execute template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]any{
		"Package":  file.GoPackageName,
		"Messages": messages,
	}); err != nil {
		log.Fatalf("execute template: %v", err)
	}

	// Format code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("format code: %v", err)
	}

	g.P(string(formatted))
}

type eventDescriptor struct {
	EventType   string
	Description string
}

type messageInfo struct {
	Name  string
	Event *eventDescriptor
}

func extractEventMeta(opts *descriptorpb.MessageOptions) *eventDescriptor {
	if opts == nil {
		return nil
	}

	if !proto.HasExtension(opts, cloudevents.E_EventMeta) {
		return nil
	}

	ext := proto.GetExtension(opts, cloudevents.E_EventMeta)
	eventMeta, ok := ext.(*cloudevents.EventMeta)
	if !ok {
		return nil
	}

	if eventMeta.GetEventType() == "" {
		return nil
	}

	return &eventDescriptor{
		EventType:   eventMeta.GetEventType(),
		Description: eventMeta.GetDescription(),
	}
}

func toFuncName(name string) string {
	// UserRegisteredPayload -> UserRegistered
	return strings.TrimSuffix(name, "Payload")
}

var tmpl = template.Must(template.New("events").Funcs(template.FuncMap{
	"toFuncName": toFuncName,
}).Parse(`// Code generated by protoc-gen-cloudevents. DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"errors"
	"fmt"
	"time"

	cloudevents "github.com/cloudevents/sdk-go/v2"
	"github.com/google/uuid"
)

// ============================================================
// Event Type Definitions
// ============================================================

const (
{{- range .Messages }}
	// EventType{{ toFuncName .Name }} {{ .Event.Description }}
	EventType{{ toFuncName .Name }} = "{{ .Event.EventType }}"
{{- end }}
)

// ============================================================
// Interface Definitions
// ============================================================

// Publisher is the interface for publishing events
type Publisher interface {
	Publish(ctx context.Context, subject string, event *cloudevents.Event) error
}

// Subscriber is the interface for subscribing to events (broadcast mode)
type Subscriber interface {
	Subscribe(ctx context.Context, subject string, handler EventHandler) error
}

// HandlerGroupSubscriber is the interface for subscribing to events (handler group mode)
type HandlerGroupSubscriber interface {
	SubscribeWithHandlerGroup(ctx context.Context, subject, group string, handler EventHandler) error
}

// EventHandler is the function signature for event handlers
type EventHandler func(context.Context, *cloudevents.Event) error

// ============================================================
// Publish Options
// ============================================================

// PublishOption is a functional option for publishing events
type PublishOption func(*publishOptions)

type publishOptions struct {
	source     string
	subject    string
	extensions map[string]interface{}
}

// WithSource sets the event source (required)
// Examples: "myapp/api-server", "myapp/controller/pod-abc"
func WithSource(source string) PublishOption {
	return func(o *publishOptions) {
		o.source = source
	}
}

// WithSubject overrides the NATS subject (optional)
// Defaults to event_type if not specified
func WithSubject(subject string) PublishOption {
	return func(o *publishOptions) {
		o.subject = subject
	}
}

// WithExtension adds CloudEvents extension attributes
func WithExtension(key string, value interface{}) PublishOption {
	return func(o *publishOptions) {
		if key != "" {
			o.extensions[key] = value
		}
	}
}

// ============================================================
// Internal Helper Functions
// ============================================================

func buildEvent(eventType string, payload interface{}, opts []PublishOption) (*cloudevents.Event, string, error) {
	options := &publishOptions{
		extensions: make(map[string]interface{}),
	}
	for _, opt := range opts {
		if opt != nil {
			opt(options)
		}
	}

	if options.source == "" {
		return nil, "", fmt.Errorf("events: source is required, use WithSource() option")
	}

	subject := options.subject
	if subject == "" {
		subject = eventType
	}

	ce := cloudevents.NewEvent()
	ce.SetID(uuid.New().String())
	ce.SetSpecVersion(cloudevents.VersionV1)
	ce.SetTime(time.Now())
	ce.SetType(eventType)
	ce.SetSource(options.source)
	ce.SetSubject(subject)

	for k, v := range options.extensions {
		ce.SetExtension(k, v)
	}

	if payload != nil {
		if err := ce.SetData(cloudevents.ApplicationJSON, payload); err != nil {
			return nil, "", fmt.Errorf("events: set data for type %s: %w", eventType, err)
		}
	}

	return &ce, subject, nil
}

func subscribeEvent[T any](ctx context.Context, bus Subscriber, eventType string,
	handler func(context.Context, *T) error) error {
	if handler == nil {
		return errors.New("events: handler is required")
	}

	return bus.Subscribe(ctx, eventType, func(eventCtx context.Context, event *cloudevents.Event) error {
		var payload T
		if data := event.Data(); len(data) > 0 {
			if err := event.DataAs(&payload); err != nil {
				return fmt.Errorf("events: decode payload for %s: %w", eventType, err)
			}
		}
		return handler(eventCtx, &payload)
	})
}

func subscribeEventWithGroup[T any](ctx context.Context, bus HandlerGroupSubscriber,
	eventType string, group string, handler func(context.Context, *T) error) error {
	if handler == nil {
		return errors.New("events: handler is required")
	}
	if group == "" {
		return errors.New("events: group is required")
	}

	return bus.SubscribeWithHandlerGroup(ctx, eventType, group,
		func(eventCtx context.Context, event *cloudevents.Event) error {
			var payload T
			if data := event.Data(); len(data) > 0 {
				if err := event.DataAs(&payload); err != nil {
					return fmt.Errorf("events: decode payload for %s: %w", eventType, err)
				}
			}
			return handler(eventCtx, &payload)
		})
}

// ============================================================
// Publish Functions
// ============================================================

{{- range .Messages }}

// Publish{{ toFuncName .Name }} publishes {{ .Event.Description }} event
// The event source must be specified using WithSource() option
func Publish{{ toFuncName .Name }}(ctx context.Context, bus Publisher,
	payload *{{ .Name }}, opts ...PublishOption) error {
	if payload == nil {
		return errors.New("events: payload is required")
	}
	event, subject, err := buildEvent(EventType{{ toFuncName .Name }}, payload, opts)
	if err != nil {
		return err
	}
	return bus.Publish(ctx, subject, event)
}
{{- end }}

// ============================================================
// Subscribe Functions (Broadcast Mode)
// ============================================================

{{- range .Messages }}

// Subscribe{{ toFuncName .Name }} subscribes to {{ .Event.Description }} events (broadcast mode)
// All subscribers will receive the event
func Subscribe{{ toFuncName .Name }}(ctx context.Context, bus Subscriber,
	handler func(context.Context, *{{ .Name }}) error) error {
	return subscribeEvent(ctx, bus, EventType{{ toFuncName .Name }}, handler)
}
{{- end }}

// ============================================================
// Subscribe Functions (Handler Group Mode)
// ============================================================

{{- range .Messages }}

// Subscribe{{ toFuncName .Name }}WithGroup subscribes to {{ .Event.Description }} events (handler group mode)
// Subscribers in the same group will compete for message consumption (load balancing)
func Subscribe{{ toFuncName .Name }}WithGroup(ctx context.Context, bus HandlerGroupSubscriber,
	group string, handler func(context.Context, *{{ .Name }}) error) error {
	return subscribeEventWithGroup(ctx, bus, EventType{{ toFuncName .Name }}, group, handler)
}
{{- end }}
`))
